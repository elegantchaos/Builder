// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
// Created by Sam Deane, 28/02/2018.
// All code (c) 2018 - present day, Elegant Chaos Limited.
// For licensing terms, see http://elegantchaos.com/license/liberal/.
// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

import Foundation
import Logger

let logger = Logger("com.elegantchaos.builder.main", handlers:[PrintHandler("print")])
let verbose = Logger("com.elegantchaos.builder.verbose")

/**
 Data structure returned by the Configuration target.

 This structure describes the products to build, the
 settings to apply to them, and a list of executables
 to build and run before and after the build.

 The executables should themselves be specified as dependencies
 of the Configuration target, and will be built as part of building
 the configuration.

 In this way the entire toolchain is bootstrappable.
 */

struct Configuration : Decodable {
    let settings : [String:String]
    let products : [String]
    let prebuild : [String]
    let postbuild : [String]

    func compilerSettings() -> [String] {
        var args : [String] = []
        settings.forEach({ (key, value) in
            args.append(contentsOf: ["-Xswiftc", "-\(key)", "-Xswiftc", "\(value)"])
        })
        return args
    }

}

/**
 Errors generated by failures at various stages of the build process.
 */

enum Failure : Error {
    case failed(output : String?, error : String?)
    case decodingFailed
}

/**
 Builder.

 The basic algorithm is:

 - build and run the "Configuration" dependency, capturing the output
 - parse this output from JSON into a configuration structure
 - iterate through the targets in configuration.prebuild, building and executing each one
 - iterate through the products in configuration.products
 - iterate through the targets in configuration.postbuild, building and executing each one

 Building is done with `swift build`, and running with `swift run`.

 */

class Builder {

    /**
     Invoke a command and some optional arguments.
     On success, returns the captured output from stdout.
     On failure, throws an error.
     */

    func run(_ command : String, arguments: [String] = []) throws -> String {
        let pipe = Pipe()
        let handle = pipe.fileHandleForReading
        let errPipe = Pipe()
        let errHandle = errPipe.fileHandleForReading

        let process = Process()
        process.launchPath = command
        process.arguments = arguments
        process.standardOutput = pipe
        process.standardError = errPipe
        process.launch()
        let data = handle.readDataToEndOfFile()
        let errData = errHandle.readDataToEndOfFile()

        process.waitUntilExit()
        let output = String(data:data, encoding:String.Encoding.utf8)
        let status = process.terminationStatus
        if status != 0 {
            logger.log("\(command) failed \(status)")
            let errorOutput = String(data:errData, encoding:String.Encoding.utf8)
            throw Failure.failed(output: output, error: errorOutput)
        }

        if output != nil {
            verbose.log("\(command) \(arguments)> \(output!)")
        }

        return output ?? ""
    }

    /**
     Invoke `swift` with a command and some optional arguments.
     On success, returns the captured output from stdout.
     On failure, throws an error.
     */

    func swift(_ command : String, arguments: [String] = []) throws -> String {

      #if os(macOS)
        let swift = "/usr/bin/swift" // should be discovered from the environment
        #else
        let swift = "/home/sam/Downloads/swift/usr/bin/swift"
        #endif

        verbose.log("running swift \(command)")
        return try run(swift, arguments: [command] + arguments)
    }

    /**
     Parse some json into a Configuration structure.
     */

    func parse(configuration json : String) throws -> Configuration {
        guard let data = json.data(using: String.Encoding.utf8) else {
            throw Failure.decodingFailed
        }

        let decoder = JSONDecoder()
        let decoded = try decoder.decode(Configuration.self, from: data)

        return decoded
    }

    /**
     Perform the build.
     */

    func build() throws {
        // try to build the Configure target
        logger.log("configuring")
        let _ = try swift("build", arguments: ["--product", "Configure"])

        // if we built it, run it, and parse its output as a JSON configuration
        // (we don't use `swift run` here as we don't want to capture any of its output)
        let json = try run(".build/debug/Configure")
        logger.log("parsing config")
        let configuration = try parse(configuration: json)

        // run any prebuild tools
        logger.log("preparing")
        for tool in configuration.prebuild {
            let _ = try swift("run", arguments: [tool, "prebuild"])
        }

        // process the configuration to do the actual build
        logger.log("building")
        let settings = configuration.compilerSettings()
        for product in configuration.products {
            let _ = try swift("build", arguments: ["--product", product] + settings)
        }

        // run any postbuild tools
        logger.log("packaging")
        for tool in configuration.postbuild {
            let _ = try swift("run", arguments: [tool, "postbuild"])
        }

        logger.log("done.")
    }

}

do {
    let builder = Builder()
    try builder.build()
} catch {
    logger.log("Failed: \(error)")
}
