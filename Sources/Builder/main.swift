import Foundation
import Logger

let logger = Logger("com.elegantchaos.builder.main")
let verbose = Logger("com.elegantchaos.builder.verbose")

/**
 Data structure returned by the Configuration target.
 
 This structure describes the products to build, the
 settings to apply to them, and a list of executables
 to build and run before and after the build.
 
 The executables should themselves be specified as dependencies
 of the Configuration target, and will be built as part of building
 the configuration.
 
 In this way the entire toolchain is bootstrappable.
 */

struct Configuration : Decodable {
    let settings : [String:String]
    let products : [String]
    let prebuild : [String]
    let postbuild : [String]
    
    func compilerSettings() -> [String] {
        var args : [String] = []
        settings.forEach({ (key, value) in
            args.append(contentsOf: ["-Xswiftc", "-\(key)", "-Xswiftc", "\(value)"])
        })
        return args
    }
    
}

/**
 Errors generated by failures at various stages of the build process.
 */

enum Failure : Error {
    case failed(output : String?, error : String?)
    case decodingFailed
}

/**
 Builder.
 
 The basic algorithm is:
 
 - build and run the "Configuration" dependency, capturing the output
 - parse this output from JSON into a configuration structure
 - iterate through the targets in configuration.prebuild, building and executing each one
 - iterate through the products in configuration.products
 - iterate through the targets in configuration.postbuild, building and executing each one
 
 Building is done with `swift build`, and running with `swift run`.
 
 */

class Builder {
    
    /**
     Invoke `swift` with a command and some optional arguments.
     On success, returns the captured output from stdout.
     On failure, throws an error.
     */
    
    func swift(_ command : String, arguments: [String] = []) throws -> String {
        logger.log("swift \(command)")
        let pipe = Pipe()
        let handle = pipe.fileHandleForReading
        let process = Process()
        process.launchPath = "/usr/bin/swift"           // should be discoverable
        process.arguments = [command] + arguments
        process.standardOutput = pipe
        process.launch()
        let data = handle.readDataToEndOfFile()
        process.waitUntilExit()
        let output = String(data:data, encoding:String.Encoding.utf8)
        let status = process.terminationStatus
        if status != 0 {
            logger.log("\(command) failed \(status)")
            throw Failure.failed(output: output, error: nil)
        }
        
        if output != nil {
            verbose.log("\(command)> \(output!)")
        }
        
        return output ?? ""
    }
    
    /**
     Parse some json into a Configuration structure.
     */
    
    func parse(configuration json : String) throws -> Configuration {
        guard let data = json.data(using: String.Encoding.utf8) else {
            throw Failure.decodingFailed
        }
        
        let decoder = JSONDecoder()
        let decoded = try decoder.decode(Configuration.self, from: data)
        
        return decoded
    }
    
    /**
     Perform the build.
     */
    
    func build() throws {
        // try to build the Configure target
        let _ = try swift("build", arguments: ["--target", "Configure"])
        
        // if we built it, run it, and parse its output as a JSON configuration
        let json = try swift("run", arguments: ["Configure"])
        let configuration = try parse(configuration: json)
        
        // process the configuration to do the actual build
        let settings = configuration.compilerSettings()
        for product in configuration.products {
            let _ = try swift("build", arguments: ["--product", product] + settings)
        }
    }
    
}

do {
    let builder = Builder()
    try builder.build()
} catch {
    logger.log("Failed: \(error)")
}

